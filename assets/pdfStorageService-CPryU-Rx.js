var Z=Object.defineProperty;var Q=(g,e,t)=>e in g?Z(g,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):g[e]=t;var $=(g,e,t)=>Q(g,typeof e!="symbol"?e+"":e,t);import{f as u,z as m,n as C,o as v,p as k,l as P,T as F,t as _,u as j,q as S,m as I,x as b,v as K,K as J}from"./firebase-vendor-OxXAdhiL.js";import{ab as A,ac as U,ad as H,ae as R,af as V,ag as M,ah as B,ai as Y}from"./index-BIOtAz8Z.js";class W{async uploadFile(e,t,s){try{const r=u().currentUser;if(!r)throw console.error("Authentication error: No user is currently signed in"),new Error("User must be authenticated to upload files");const n=A(U,t),o={...s,customMetadata:{userId:r.uid,uploadedAt:Date.now().toString(),...s==null?void 0:s.customMetadata}},i=await H(n,e,o);return await R(i.ref)}catch(a){throw console.error("Error uploading file:",a),a}}async getFileUrl(e){try{const t=A(U,e);return await R(t)}catch(t){throw console.error("Error getting file URL:",t),t}}async deleteFile(e){try{const t=A(U,e);await V(t)}catch(t){throw console.error("Error deleting file:",t),t}}async listFiles(e){try{const t=A(U,e);return(await M(t)).items.map(a=>a.fullPath)}catch(t){throw console.error("Error listing files:",t),t}}async getFileMetadata(e){try{const t=A(U,e);return await B(t)}catch(t){throw console.error("Error getting file metadata:",t),t}}async updateFileMetadata(e,t){try{const s=A(U,e);return await Y(s,{customMetadata:t})}catch(s){throw console.error("Error updating file metadata:",s),s}}generateFilePath(e,t){const a=u().currentUser;if(!a)throw console.error("Authentication error: No user is currently signed in"),new Error("User must be authenticated to generate file paths");const r=a.uid,n=Date.now(),o=t.replace(/[^a-zA-Z0-9.-]/g,"_");return`${e}/${r}/${n}_${o}`}isAuthenticated(){return!!u().currentUser}}const O=new W;var x=(g=>(g.USER="user",g.ADMIN="admin",g.SUPERUSER="superuser",g))(x||{});class X{constructor(){$(this,"USERS_COLLECTION","users")}async getCurrentUserRole(){const t=u().currentUser;if(!t)return x.USER;try{const s=m(),a=C(s,this.USERS_COLLECTION,t.uid),r=await v(a);return r.exists()&&r.data().role||x.USER}catch(s){return console.error("Error fetching user role:",s),x.USER}}async hasAdminAccess(){const e=await this.getCurrentUserRole();return[x.ADMIN,x.SUPERUSER].includes(e)}async getUserDetails(e){try{const t=m(),s=C(t,this.USERS_COLLECTION,e),a=await v(s);if(a.exists()){const r=a.data(),o=u().currentUser;return{id:e,email:r.email||"",displayName:r.displayName||"",role:r.role||x.USER,photoURL:r.photoURL||(o==null?void 0:o.photoURL)}}return null}catch(t){return console.error("Error fetching user details:",t),null}}async getUserDetailsMap(e){const s=[...new Set(e)].map(r=>this.getUserDetails(r));return(await Promise.all(s)).reduce((r,n)=>(n&&(r[n.id]=n),r),{})}}const q=new X,G={expiryDays:30,restrictAccess:!0,isShared:!1,visibility:"private"};class tt{constructor(){$(this,"STORAGE_PATH","pdfs");$(this,"COLLECTION_NAME","pdfs")}generateDateBasedPath(e,t){const s=t||new Date,a=String(s.getDate()).padStart(2,"0"),r=String(s.getMonth()+1).padStart(2,"0"),n=s.getFullYear(),o=`${a}-${r}-${n}`;return`${this.STORAGE_PATH}/${o}`}getTodaysFolderPath(){const t=u().currentUser;return t?this.generateDateBasedPath(t.uid):null}getTodaysDateString(){const e=new Date,t=String(e.getDate()).padStart(2,"0"),s=String(e.getMonth()+1).padStart(2,"0"),a=e.getFullYear();return`${t}-${s}-${a}`}getDateString(e){const t=String(e.getDate()).padStart(2,"0"),s=String(e.getMonth()+1).padStart(2,"0"),a=e.getFullYear();return`${t}-${s}-${a}`}getFolderPathForDate(e){const s=u().currentUser;return s?this.generateDateBasedPath(s.uid,e):null}async listTodaysFiles(){try{if(!u().currentUser)throw new Error("User must be authenticated to access files");return await this.listFilesForDate(new Date)}catch(e){if(e instanceof Error&&e.message.includes("folder does not exist"))return[];throw e}}async listFilesForDate(e){try{if(!u().currentUser)throw new Error("User must be authenticated to access files");const a=this.getDateString(e),r=`${this.STORAGE_PATH}/${a}`,n=[];try{const o=await this.listFolderContents(r);n.push(...o)}catch{return[]}return n}catch(t){if(t instanceof Error&&t.message.includes("folder does not exist"))return[];throw t}}async uploadPdf(e,t,s,a=G){try{const n=u().currentUser;if(!n)return console.error("Authentication error: No user is currently signed in"),{success:!1,error:"User must be authenticated to upload files",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}};const o=Date.now(),i=n.uid,c=this.generateDateBasedPath(i),d=t.replace(/[^a-zA-Z0-9.-]/g,"_"),h=new Date().toISOString().replace(/[:.]/g,"-").substring(11,19),y=`${c}/${h}_${d}`,f=Math.max(1,Math.min(90,a.expiryDays)),l=new Date;l.setDate(l.getDate()+f);const p=l.getTime(),w={userId:i,fileId:"",expiresAt:p.toString(),visibility:a.visibility||"private",description:s.description||a.description||""},D=A(U,y),E=await H(D,e,{contentType:"application/pdf",customMetadata:w}),z=await R(E.ref),N={userId:i,uploadedAt:o,expiresAt:p,originalFileName:t,fileSize:e.size,restrictAccess:a.restrictAccess,isShared:a.isShared,visibility:a.visibility||"private",storagePath:y,stats:{categoryCount:s.categoryCount,productCount:s.productCount,sortConfig:s.sortConfig},description:s.description||a.description},T=m(),L=await k(P(T,this.COLLECTION_NAME),{...N,storagePath:y,downloadUrl:z,uploadedAt:F.fromMillis(o),expiresAt:F.fromMillis(p)});return await Y(D,{customMetadata:{fileId:L.id}}),{fileId:L.id,downloadUrl:z,expiresAt:p,isShared:a.isShared,restrictAccess:a.restrictAccess,metadata:N,success:!0}}catch(r){return console.error("Error uploading PDF:",r),{success:!1,error:r instanceof Error?r.message:"Unknown error during upload",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}}}}async uploadPdfForDate(e,t,s,a,r=G){try{const o=u().currentUser;if(!o)return console.error("Authentication error: No user is currently signed in"),{success:!1,error:"User must be authenticated to upload files",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}};console.debug("Starting PDF upload for date:",s.toISOString().split("T")[0],"with auth user:",o.uid);const i=Date.now(),c=o.uid,d=this.generateDateBasedPath(c,s),h=t.replace(/[^a-zA-Z0-9.-]/g,"_"),y=new Date().toISOString().replace(/[:.]/g,"-").substring(11,19),f=`${d}/${y}_${h}`,l=Math.max(1,Math.min(90,r.expiryDays)),p=new Date;p.setDate(p.getDate()+l);const w=p.getTime(),D={userId:c,fileId:"",expiresAt:w.toString(),visibility:r.visibility||"private",description:a.description||r.description||"",selectedDate:s.toISOString().split("T")[0]},E=A(U,f),z=await H(E,e,{contentType:"application/pdf",customMetadata:D}),N=await R(z.ref),T={userId:c,uploadedAt:i,expiresAt:w,originalFileName:t,fileSize:e.size,restrictAccess:r.restrictAccess,isShared:r.isShared,visibility:r.visibility||"private",storagePath:f,stats:{categoryCount:a.categoryCount,productCount:a.productCount,sortConfig:a.sortConfig},description:a.description||r.description,selectedDate:s.toISOString().split("T")[0]},L=m();return{fileId:(await k(P(L,this.COLLECTION_NAME),{userId:c,uploadedAt:F.fromMillis(i),expiresAt:F.fromMillis(w),originalFileName:t,fileSize:e.size,restrictAccess:r.restrictAccess,isShared:r.isShared,visibility:r.visibility||"private",downloadUrl:N,storagePath:f,stats:T.stats,description:T.description,selectedDate:s.toISOString().split("T")[0]})).id,downloadUrl:N,expiresAt:w,isShared:r.isShared,restrictAccess:r.restrictAccess,metadata:T,success:!0}}catch(n){return console.error("Error uploading PDF for date:",n),{success:!1,error:n instanceof Error?n.message:"Unknown error during upload",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}}}}async getPdfDetails(e){try{if(!u().currentUser)throw new Error("User must be authenticated to view file details");const a=m(),r=C(a,this.COLLECTION_NAME,e),n=await v(r);if(!n.exists())return null;const o=n.data(),i={userId:o.userId,uploadedAt:o.uploadedAt.toMillis(),expiresAt:o.expiresAt.toMillis(),originalFileName:o.originalFileName,fileSize:o.fileSize,restrictAccess:o.restrictAccess,isShared:o.isShared,visibility:o.visibility,storagePath:o.storagePath,stats:o.stats,description:o.description,selectedDate:o.selectedDate};return{fileId:e,downloadUrl:o.downloadUrl,expiresAt:i.expiresAt,isShared:i.isShared,restrictAccess:i.restrictAccess,metadata:i,success:!0}}catch(t){throw console.error("Error retrieving PDF details:",t),t}}async deletePdf(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete files");const a=m(),r=C(a,this.COLLECTION_NAME,e),n=await v(r);if(!n.exists())throw new Error("File not found");const o=n.data();await O.deleteFile(o.storagePath),await _(r)}catch(t){throw console.error("Error deleting PDF:",t),t}}async updatePdfExpiry(e,t){try{if(!u().currentUser)throw new Error("User must be authenticated to update files");const r=Math.max(1,Math.min(90,t)),n=new Date;n.setDate(n.getDate()+r);const o=n.getTime(),i=m(),c=C(i,this.COLLECTION_NAME,e),d=await v(c);if(!d.exists())throw new Error("File not found");const h=d.data();await j(c,{expiresAt:F.fromMillis(o)}),await O.updateFileMetadata(h.storagePath,{expiresAt:o.toString()})}catch(s){throw console.error("Error updating PDF expiry:",s),s}}async listAllPdfs(){try{if(!u().currentUser)throw new Error("User must be authenticated to list files");const s=m(),a=S(P(s,this.COLLECTION_NAME)),r=await I(a);if(r.empty)return[];const n=Date.now(),o=[];return r.forEach(i=>{const c=i.data(),d=c.expiresAt.toMillis();d<n||o.push({fileId:i.id,downloadUrl:c.downloadUrl,expiresAt:d,isShared:c.isShared,restrictAccess:c.restrictAccess,metadata:{userId:c.userId,uploadedAt:c.uploadedAt.toMillis(),expiresAt:d,originalFileName:c.originalFileName,fileSize:c.fileSize,restrictAccess:c.restrictAccess,isShared:c.isShared,visibility:c.visibility,storagePath:c.storagePath,stats:c.stats,description:c.description,selectedDate:c.selectedDate},success:!0})}),o.sort((i,c)=>c.metadata.uploadedAt-i.metadata.uploadedAt)}catch(e){throw console.error("Error listing PDFs:",e),e}}async listUserPdfs(){return this.listAllPdfs()}async cleanupExpiredFiles(){try{if(!u().currentUser)throw new Error("User must be authenticated to clean up files");const s=Date.now(),a=m(),r=S(P(a,this.COLLECTION_NAME),b("expiresAt","<=",F.fromMillis(s))),n=await I(r);if(n.empty)return 0;let o=0;for(const i of n.docs){const c=i.data();try{await O.deleteFile(c.storagePath),await _(i.ref),o++}catch(d){console.error(`Failed to delete expired file ${i.id}:`,d)}}return o}catch(e){throw console.error("Error cleaning up expired files:",e),e}}async listAllFolders(){try{if(!u().currentUser)throw new Error("User must be authenticated to list folders");const s=A(U,this.STORAGE_PATH),a=[],n=(await M(s)).prefixes.map(async i=>{const c=i.fullPath,d=i.name;try{const h=await M(i);let y=0,f=new Date(0);const l=h.items.map(async p=>{try{const w=await B(p),D=w.size||0,E=new Date(w.updated);y+=D,E>f&&(f=E)}catch(w){console.warn(`Failed to get metadata for ${p.fullPath}:`,w)}});return await Promise.all(l),{path:c,name:d,fileCount:h.items.length,totalSize:y,lastModified:f.getTime()===0?new Date:f}}catch(h){return console.warn(`Failed to process date folder ${d}:`,h),null}});return(await Promise.all(n)).forEach(i=>{i&&a.push(i)}),a.sort((i,c)=>i.name.localeCompare(c.name))}catch(e){throw console.error("Error listing all folders:",e),e}}async listUserFolders(){return this.listAllFolders()}async listFolderContents(e){try{if(!u().currentUser)throw new Error("User must be authenticated to list folder contents");const a=A(U,e),n=(await M(a)).items.map(async i=>{var c,d;try{const[h,y]=await Promise.all([B(i),R(i)]),f=m();let l=null,p=null;try{const w=S(P(f,this.COLLECTION_NAME),b("storagePath","==",i.fullPath)),D=await I(w);if(!D.empty){const E=D.docs[0];p=E.id,l=E.data()}}catch(w){console.warn(`Failed to get Firestore data for ${i.fullPath}:`,w)}return{path:i.fullPath,name:i.name,size:h.size||0,lastModified:new Date(h.updated),downloadUrl:y,fileId:p,metadata:l?{userId:l.userId,uploadedAt:((c=l.uploadedAt)==null?void 0:c.toMillis())||0,expiresAt:((d=l.expiresAt)==null?void 0:d.toMillis())||0,originalFileName:l.originalFileName,fileSize:l.fileSize,restrictAccess:l.restrictAccess,isShared:l.isShared,visibility:l.visibility,storagePath:l.storagePath,stats:l.stats,description:l.description,selectedDate:l.selectedDate}:void 0}}catch(h){return console.error(`Failed to process file ${i.fullPath}:`,h),null}});return(await Promise.all(n)).filter(Boolean).sort((i,c)=>i.name.localeCompare(c.name))}catch(t){throw console.error("Error listing folder contents:",t),t}}async getFolderSize(e){try{if(!u().currentUser)throw new Error("User must be authenticated to get folder size");const a=A(U,e),r=await M(a);let n=0;const o=r.items.map(async c=>{try{return(await B(c)).size||0}catch(d){return console.warn(`Failed to get size for ${c.fullPath}:`,d),0}});return n=(await Promise.all(o)).reduce((c,d)=>c+d,0),n}catch(t){throw console.error("Error getting folder size:",t),t}}async deleteFolderRecursive(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete folders");const a=A(U,e),r=await M(a),n=r.items.map(async i=>{try{const c=m(),d=S(P(c,this.COLLECTION_NAME),b("storagePath","==",i.fullPath)),y=(await I(d)).docs.map(f=>_(f.ref));await Promise.all(y),await O.deleteFile(i.fullPath)}catch(c){throw console.error(`Failed to delete file ${i.fullPath}:`,c),c}}),o=r.prefixes.map(async i=>{await this.deleteFolderRecursive(i.fullPath)});await Promise.all([...n,...o])}catch(t){throw console.error("Error deleting folder recursively:",t),t}}async deleteFile(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete files");const a=m(),r=S(P(a,this.COLLECTION_NAME),b("storagePath","==",e)),o=(await I(r)).docs.map(i=>_(i.ref));await Promise.all(o),await O.deleteFile(e)}catch(t){throw console.error("Error deleting file:",t),t}}async deleteMultipleFiles(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete files");const a=e.map(r=>this.deleteFile(r));await Promise.all(a)}catch(t){throw console.error("Error deleting multiple files:",t),t}}async validateUserAccess(e){try{if(!u().currentUser)throw new Error("User must be authenticated to access files");return!0}catch(t){throw console.error("Error validating user access:",t),t}}async listAllUserPdfs(e={}){try{if(!await q.hasAdminAccess())throw new Error("Insufficient permissions to view all PDFs");const s=m(),a=P(s,this.COLLECTION_NAME);let r=S(a);if(e.filterByDate){const l=new Date(e.filterByDate);l.setHours(0,0,0,0);const p=new Date(e.filterByDate);p.setHours(23,59,59,999),r=S(r,b("uploadedAt",">=",F.fromDate(l)),b("uploadedAt","<=",F.fromDate(p)))}e.searchTerm&&(r=S(r,b("originalFileName",">=",e.searchTerm),b("originalFileName","<=",e.searchTerm+"")));const n=e.sortBy||"uploadedAt",o=e.sortOrder||"desc";r=S(r,K(n,o));const i=e.pageSize||50,c=S(r,J(i)),h=(await I(c)).docs.map(l=>({fileId:l.id,downloadUrl:l.data().downloadUrl,expiresAt:l.data().expiresAt.toMillis(),isShared:l.data().isShared,restrictAccess:l.data().restrictAccess,metadata:{userId:l.data().userId,uploadedAt:l.data().uploadedAt.toMillis(),expiresAt:l.data().expiresAt.toMillis(),originalFileName:l.data().originalFileName,fileSize:l.data().fileSize,restrictAccess:l.data().restrictAccess,isShared:l.data().isShared,visibility:l.data().visibility,storagePath:l.data().storagePath,stats:l.data().stats,description:l.data().description,selectedDate:l.data().selectedDate},success:!0})),f=(await I(r)).size;return{pdfs:h,totalCount:f,page:e.page||1,pageSize:i}}catch(t){throw console.error("Error listing all user PDFs:",t),t}}async getUserDetailsForPdfs(e){try{if(!await q.hasAdminAccess())throw new Error("Insufficient permissions to retrieve user details");const s=m(),a=[];for(const r of e){const n=C(s,this.COLLECTION_NAME,r),o=await v(n);if(o.exists()){const i=o.data().userId;i&&!a.includes(i)&&a.push(i)}}return await q.getUserDetailsMap(a)}catch(t){throw console.error("Error getting user details for PDFs:",t),t}}}const it=new tt;export{G as d,it as p,q as r};
